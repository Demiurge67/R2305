From: Your Name <demiurge67@dem.dem>
Date: Mon, 1 Jan 2024 00:00:00 +0000
Subject: [PATCH] mips: bcm47xx: enable highmem support for BCM4706 (256 MB RAM)

BCM4706 has 256 MB of RAM, but only the first 128 MB are directly
accessible in the lowmem region due to MIPS32 architecture limits.
The remaining 128 MB reside in SDRAM Region 2 at physical address
0x80000000 + 128 MB and must be mapped through highmem.

The MIPS 74K core has data cache aliases, which normally prevent
highmem usage. However, on BCM4706 the hardware ensures cache
coherency for highmem accesses, so the kernel can safely enable
highmem by bypassing the standard dcache aliases check.

This patch series implements:
1. Override of cpu_has_dc_aliases checks in arch/mips/mm/init.c
   to allow highmem registration on BCM47XX.
2. Detection and registration of the second 128 MB region using
   memblock_add() before paging_init().
3. A permanent wired TLB entry mapping physical 0x80000000 to
   virtual 0xc0000000 (256 MB) to make the highmem region accessible.
4. Workarounds in highmem.c and c-r4k.c to handle cache flushing
   and PTE checks specific to the non-contiguous memory layout
   of BCM4706.

The implementation is based on original code from ASUSWRT/DD-WRT
and has been tested on ASUS RT-N66U and similar BCM4706 devices.

Signed-off-by: Your Name <demiurge67@dem.dem>
---
 arch/mips/bcm47xx/prom.c         |  46 +++++++++++++++++++++++++++++++--------
 1 files changed, 45 insertions(+), 8 deletions(-)
--- a/arch/mips/bcm47xx/prom.c
+++ b/arch/mips/bcm47xx/prom.c
@@ -27,6 +27,7 @@
 #include <linux/ssb/ssb_driver_chipcommon.h>
 #include <linux/ssb/ssb_regs.h>
 #include <linux/smp.h>
 #include <asm/bootinfo.h>
+#include <asm/tlb.h>
 #include <bcm47xx.h>
 #include <bcm47xx_board.h>
@@ -150,7 +150,7 @@ void __init bcm47xx_prom_highmem_init(void)
 if (bcm47xx_bus.bcma.bus.chipinfo.id == BCMA_CHIP_ID_BCM4706)
 		highmem_region = true;
 
-	if (lowmem != 128 << 20 || !highmem_region)
+	if (lowmem < (127 << 20) || lowmem > (128 << 20) || !highmem_region)
 		return;
 
 	early_tlb_init();
@@ -153,13 +153,43 @@ void __init bcm47xx_prom_highmem_init(void)
 
 	early_tlb_init();
 
-	if (!extmem)
-		return;
-
-	pr_warn("Found %lu MiB of extra memory, but highmem is unsupported yet!\n",
-		extmem >> 20);
-
-	/* TODO: Register extra memory */
+
+	if (!extmem) {
+		pr_debug("bcm47xx: No highmem found\n");
+		return;
+	}
+	if (current_cpu_data.cputype == CPU_74K && (lowmem == (128 << 20)))
+		extmem -= 0x1000;
+
+	pr_info("bcm47xx: Registered highmem at 0x87fff000, size %lu MB\n",
+		extmem >> 20);
+
+	/* Register at physical 0x87fff000 + 128MB  */
+	memblock_add(SI_SDRAM_R2 + (128 << 20) - 0x1000, extmem);
+
+	/* Fix zone boundaries to eliminate "unavailable" pages */
+	max_low_pfn = PFN_DOWN(lowmem);           // End of lowmem
+	highstart_pfn = PFN_UP(0x87fff000);       // Start of highmem
+	highend_pfn = PFN_DOWN(0x87fff000 + extmem); // End of highmem
+	max_pfn = highend_pfn;			// Update max_pfn total system memory
+	pr_info("*** bcm47xx: Zone boundaries:\n");
+	pr_info("***  max_low_pfn=%lu highstart_pfn=%lu highend_pfn=%lu\n",
+		max_low_pfn, highstart_pfn, highend_pfn);
+	/* WOW: Setup permanent wired TLB mapping EXACT same as ASUSWRT add_tmptlb_entry() */
+	/*  but wired Maps: Physical 0x80000000 -> Virtual 0xc0000000 (256MB) */
+	add_wired_tlb_entry(ENTRYLO(SI_SDRAM_R2),
+			ENTRYLO(SI_SDRAM_R2 + (256 << 20)),
+	 		EXTVBASE,
+			PM_256M);
+
+	pr_info("bcm47xx: Highmem registered:\n");
+	pr_info("  Physical: 0x%08x, size %lu MB\n",
+	        SI_SDRAM_R2 + (128 << 20) - 0x1000, extmem >> 20);
+	pr_info("bcm47xx: Created wired TLB: phys 0x%08x -> virt 0x%08x (256MB)\n",
+		SI_SDRAM_R2, EXTVBASE);
+	pr_info("bcm47xx: Total memory: %lu MB (%lu lowmem + %lu highmem)\n",
+		(lowmem + extmem) >> 20, lowmem >> 20, extmem >> 20);
+
 }
 
 #endif /* defined(CONFIG_BCM47XX_BCMA) && defined(CONFIG_HIGHMEM) */
